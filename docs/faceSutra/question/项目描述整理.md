- 慧影云核销反核销优化：之前通过实时数据库进行预算更新，之后将预算放到redis中，通过redis原子性命令decr/incr进行预算的扣减和增加。将需要持久化的数据通过mq异步处理。
- 出现过一次服务雪崩，POS从票务模块获取作为信息渲染影厅的时候，因为某些厅的座位数多，加上一些影厅和座位的附加信息，票务处理慢+传输的数据量过大（每条连接最多可压满7MB），导致票务的其它服务也无法正常使用，由于dubbo默认采用的是单一长连接，所以我们增加了连接数，并且加大了该接口的超时时间
- 大量营销活动审批完成之后，需要将该活动的信息加载到Drools引擎中，会造成短暂性的无法匹配活动。解决方式是，将营销服务节点分为A和B两部分，A先进行活动规则的加载，此时请求到A的活动匹配请求，直接拒绝，通过dubbo的重试机制，让消费者最终请求到B部分，当A加载完之后，再加载B。
- 规则引擎拆分，现在的活动规则时放到一个池子里面进行匹配，考虑是按照租户和业务方类型将活动池子进行拆分。而且现在Drools匹配规则的时候，如果某一个规则报错，就不进行后续的匹配，按照租户区分，可以避免出现系统瘫痪的问题。


核销：
	
	核销活动总次数限制、单用户限制、售票数、优惠金额、订单数   
	一个核销接口调用会核销多个不定的种类限制
	采用责任链的模式进行各个种类的核销
	通过数据库事务保证单次核销请求的数据一致性
	因为性能问题，每次查询剩余预算，加锁，进行更新，这样会核销造成性能上的瓶颈、
	后期改造是将剩余种类的预算放入redis中，通过setnx实现初始化，incrby实现原子性的预算更新，
	在预算更新完成后，通过mq的方式实现数据库的数据异步更新，更新数据库时插入undo表，如果后续责任链的节点更新失败（预算不足），
	通过批次号执行已经更新预算的回滚
	为什么不直接先全部更新redis预算，全部成功再发mq更新数据库，是因为要保证一致性，redis的更新需要保证原子性，
	这样的话，需要通过lua脚本保证原子性，避免前面的预算更新成功，后面的预算因为程序异常更新失败。但是lua是原子性执行的，
	如果逻辑执行复杂，会造成执行时间过长，阻塞其它命令的执行，而继续通过责任链的方式，也方便拓展。


- 慧影云描述：
- 中台描述：
- 架构部工作描述：