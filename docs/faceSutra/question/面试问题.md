并发篇  
---
- Q：synchronized了解过吗？
- A：jdk提供的非公平、可重入的同步阻塞原语，能够保证原子性、可见性和有序性，用来修饰方法和代码块。修饰实例方法时，锁的是当前实例对象，修饰静态方法时，锁的是当前类的Class对象，修饰代码块时，锁的是指定的锁对象。通过反编译class文件可以看到，在同步代码块前后会有monitorenter和monitorexit两个命令。在同步方法的flags属性中，包含ACC_SYNCHRONIZED标识。
- Q：了解过synchronized底层实现吗？
- A：jvm中每个对象都有一个MonitorObject与之关联，当锁升级为重量级锁时，会在对象头的mark word区域存储指向Monitor的指针，当线程获取锁成功时，记录当前持有锁的线程为当前线程，并且获取锁的次数为1，当获取锁失败时，会将当前线程放入Monitor的EntryList中，如果线程执行临界区代码时，调用了wait()方法，那么线程会释放锁并且进入waitlist中等待唤醒或者超时唤醒。
- Q：你刚才说到了锁升级，那么锁时怎么升级的呢？
- A：因为线程的阻塞和唤醒涉及到内核态和用户态的切换，为了节省资源的消耗，并且研究发现，代码中大部分锁都是由一个线程获取。所以对synchronized进行了优化。将锁的状态分为偏向锁、轻量级锁、重量级锁，通过mark word中的锁状态标识来区分，01代表偏向锁和无锁，00代表轻量级锁，10代表重量级锁。下面说一下锁的升级过程，A线程尝试获取锁，在mark word中设置当前线程id，此后B线程获取锁，如果A线程存活并且仍在运行锁临界区代码，那么将锁升级为轻量级锁，首先将A暂停，锁标识设置为00，唤醒A线程，将锁对象的hashcode和gc等信息存放在A线程的栈中，mark word设置为指向栈中锁记录的指针，然后B会尝试自旋获取锁，如果B在特定时间内未获取到锁或者在B获取锁的过程中，C线程也来获取锁，那么会将锁升级为重量级锁，将状态为设置为10，在mark word中记录指向Monitor的指针，Monitor占有锁的线程设置为A，B和C进入Monitor的阻塞队列中。
- Q：偏向锁、轻量级锁存在的意义？
- A：偏向锁是为了针对那些几乎没有竞争的状态，每次都是同一个线程获取锁。轻量级锁是为了应对竞争少，并且临界区执行快，其他线程可以通过自旋很快获取锁的场景。
- Q：还有其它的优化吗？
- A：锁消除、锁粗化、自旋锁、自适应自旋。锁消除是JIT编译的结果，将不可能出现并发竞争的锁消除掉。锁粗化是将临近的锁合并为一个，避免多次获取锁。自旋锁是为了避免线程阻塞和唤醒对资源的消耗，在获取锁是尝试通过自旋获取锁。自适应自旋是自旋的改进，如果在同一个锁对象上过，自旋等待刚刚获取成功，那么虚拟机会认为这次自旋有很大几率获取成功，进而它将允许自旋等待时间持续相对更长的时间，如果在一个锁上很少通过自旋获取锁成功，那么可能会取消该锁对象的自旋过程。
- ---
- Q：volatile了解过吗？
- A：volatile能保证可见性和一定程度的有序性。可见性，对一个变量的读，总是能看到任意线程对这个变量最后的写入。有序性，确保在指令重排序时，保证当执行到一个volatile变量的读或写时，在其前面的操作已经全部完成，在其后面的操作都没有进行。
- Q：volatile如何实现的？
- A：volatile变量在生成的汇编语言中，比其它变量多了一个lock的前缀，也叫内存屏障。内存屏障是一个让cpu处理单元中的内存状态对其它处理单元可见的一项技术。内存屏障有两个作用，首先，通过确保从另一个CPU来看屏障两边的所有指令都是正确的程序顺序，而保持程序顺序的外部可见性。其次，实现了内存数据的可见性，确保内存数据会同步到cpu缓存子系统。
- ---
- Q：AQS了解过吗？
- A：AQS是jdk提供的一个同步器，包括了原子式状态维护、阻塞和唤醒线程、同步队列的功能。并发包中的很多并发组件都是通过AQS实现的，比如ReetrantLock、CyclicBarrier。
- ---
- Q：悲观锁和乐观锁？
- A：悲观锁是每次去拿数据时，都认为会被别人修改，所以每次拿数据时，都会加锁，这样别人就会被阻塞。乐观锁是每次拿数据时，都认为别人不会修改，所以不会上锁，但是会在提交更新的时候，判断在此期间有没有别人修改了数据
- Q：悲观锁和乐观锁分别有哪些实现？
- A：悲观锁有synchronized和ReentrantLock等。乐观锁可以通过cas和版本号（数据库的mvcc）。
- Q：cas有哪些问题呢？
- A：会出现ABA的问题以及如果自旋cas长时间不成功，会给cpu带来非常大的消耗
- ---
- Q：synchronized和lock的区别？
- A：
	- 1.synchronized是非公平的、lock支持公平和非公平两种。
	- 2.synchronized在临界区执行完之后会自动释放锁，而lock需要手动释放。
	- 3.synchronized可以修饰方法和代码块，lock需要指定同步块的开始和结束。
	- 4.lock可以响应中断和尝试获取锁，超时获取锁，synchronized不行
- ---
- Q：java内存模型了解吗？
- ---

集合篇
---
- Q：

- ---

并发包篇
---
- Q：

- ---
jvm篇
---
- Q：
- ---

分布式篇
---
- Q：
- ---

消息队列篇
---
- Q：
- ---
redis篇
---
- Q：Redis数据类型有哪些？
- A：String、Hash、List、Set、Sorted Set、BitMap、Geo、Hyperloglog

- ---

数据库篇
---
- Q：
- ---

spring篇
---
- Q：

（0）redis为什么是key，value的，为什么不是支持SQL的？
（1）redis是多线程还是单线程？（回答单线程的请回吧，为什么请回，请往下看）
（2）redis的持久化开启了RDB和AOF下重启服务是如何加载的？(10个人9个回答错误)
（3）redis如果做集群该如何规划？AKF/CAP如何实现和设计？
（4）10万用户一年365天的登录情况如何用redis存储，并快速检索任意时间窗内的活跃用户？
（5）redis的5种Value类型你用过几种，能举例吗？
（6）100万并发4G数据，10万并发400G数据，如何设计Redis存储方式？