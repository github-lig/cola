- **集合**：List、Set、Map
	- ***List***：Vector、ArrayList、LinkedList
		- Vector的get和set等方法是被synchronized修饰的同步方法，是线程安全的，ArrayList、LinkedList是非线程安全的。
		- Vector是基于数组，每次扩容是都是扩大为原有容量的2倍。ArrayList也是基于数组，每次扩容为原来的1.5倍（Arrays.copyOf）。LinkedList是基于双向链表。
		- 对于随机的get和set，ArrayList更快。一般情况下删除和添加元素，LinkedList会相对快一些，因为ArrayList要移动数据。
		- LinkedList可以用来实现栈、队列、双端队列等结构。
	- ***Map***：字段表，HashMap、TreeMap、LinkedHashMap、HashTable、ConcurrentHashMap
		- TreeMap可以对key进行排序，排序可以按照自然排序和自定义Comparator两种方式。基于红黑树实现。
		- HashMap，key和value都可为null，key为null时，取的hash为0。TreeMap，key不可为null，value可为null。HashTable，key和value都不可为null。
		- HashMap在HashTable的基础上进行了优化，移除了对线程安全的支持，如果需要使用线程安全的HashMap，可以使用并发包的ConcurrentHashMap。
		- TreeMap比较特殊的方法：firstKey返回第一个key、lastKey返回最后一个key、lowerKey(K key)返回小于入参key的key、ceilingKey(K key)返回大于入参key的key、subMap(K fromKey, K toKey)返回从fromKey到toKey的元素，返回类型为SortedMap
		- ConcurrentHashMap相当于是HashMap的优化版，添加了线程安全的支持，采用了分段加锁技术。
		- LinkedHashMap，基于HashMap，维护了一份双向链表（head、tail）用于存储插入顺序/访问顺序。当维护访问顺序时，如果插入顺序为A,B,C,D。然后访问依次D、B两个元素，遍历Map得到的顺序为A,C,D,B。
	- ***Set***：HashSet、TreeSet、LinkedHashSet
		- HashSet基于HashMap实现。TreeSet基于TreeMap。LinkedHashSet基于LinkedHashMap。
	- ***Collections***：该类提供了synchronizedXXX方法可以将集合转换为线程安全的集合。实质上是使用装饰器模式为我们添加了同步功能。
- **SubList**：List.subList(int fromIndex, int toIndex)前闭后开。实质上操作的还是原List，每次进行操作时都会校验原List的元素个数有没有更改。
- **HashMap**：数组+链表/红黑树。
	- 数组长度为容量大小（默认初始为16，必须是2的倍数，在计算元素的数组index时，使用(n - 1) & hash位运算和 hash % n的结果是一致的，且位运算比取余快很多）
	- 当已用容量>容量*加载因子（默认为0.75f），HashMap扩容，每次扩容为之前的2倍（initialCapacity << 1），最大容量为Integer.MAX_VALUE（1 << 30）
	- 链表树化：树化链表长度阈值为8（>=TREEIFY_THRESHOLD），树化容量阈值为64（>=MIN_TREEIFY_CAPACITY）
	- 当红黑树长度小于6，将红黑树转化为链表
	- HashMap进行get时，先计算Hash值，找到所属链表的首节点，然后对链表中的节点进行== || equals比较。红黑树结构类似于二分法查找，能够提高查询速度
	- put和get计算hash值时，不是直接使用hashCode()方法，而是(h = key.hashCode()) ^ (h >>> 16)。作用是扰乱hash值，降低hash碰撞的几率。右移之后会混合原有hashCode的高低位
- **快速失败、安全失败**：
	- ***快速失败***：当使用迭代器遍历集合时，如果自身通过非迭代器方法进行元素的添加和删除或者其它线程对集合元素个数进行了修改，则迭代器继续进行操作时，会出现ConcurrentModificationException异常
	- ***安全失败***：对集合进行迭代的时候，先对集合进行copy，再进行遍历，不会出现快速失败。缺点在于访问不到最新的数据。
- **Iterator和ListIterator**：Iterator可以应用于所有的集合，List、Set、Map及其子类型。ListIterator只能应用于List及其子类型。Iterator可以从头向后遍历、删除元素。ListIterator可以从某个index开始向前/向后遍历，可以删除、覆盖某个索引的元素、在当前index位置添加元素。
	- 需要注意的是，使用迭代器进行遍历时，迭代器指向的是元素前面的区域，不会直接指向元素。类似于next()方法，都是取迭代器当前位置后的第一个元素。
- **System.arraycopy(Object src,  int  srcPos, Object dest, int destPos,int length)**：进行数组copy的本地方法。
- **Comparator、Comparable**：两个都是接口。Comparator比较器，实现该接口可以对某些指定类型的类进行比较。Comparable，实现了该接口的类具有排序的能力。
- **队列**：先进先出。jdk提供了7个阻塞队列
	- ArrayblackingQueue：基于数组实现的有界阻塞队列
	- LinkedBlackingQueue：基于链表实现的有界阻塞队列
	- PriorityBlockingQueue：支持优先级排序的无界队列（存储的是数组）
	- DelayQueue：使用优先级队列实现的支持延迟获取元素的队列
	- SynchronizedQueue：一个不存储元素的阻塞队列，put必须有take配对才能返回。
	- LinkedTransferQueue：由链表结构组成的无界阻塞队列
	- LinkedBlockingDeque：由链表实现的双向阻塞队列
- **队列方法**：下述描述中add和remove和element方法均为AbstractQueue抽象类的默认实现的描述，各个队列实现类会有变化
	- offer和add：当对某些有界队列进行元素的添加时，如果队列已满，add会返回IllegalStateException异常，而offer会返回false
	- poll和remove：进行头部元素的删除时，如果队列为空，remove会返回NoSuchElementException异常，而poll会返回null
	- peek和element：返回队列头部的元素，如果队列为空，element方法会返回NoSuchElementException异常，peek会返回null
- **阻塞队列**：put和take：put，向队列中添加一个元素，如果队列已满，则阻塞。take，返回队列头部元素，如果队列为空，则阻塞。
	