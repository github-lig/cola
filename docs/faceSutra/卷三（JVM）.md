JVM和JMM-类初始化-对象的创建-句柄-对象的回收-对象大小计算  
JMM-虚拟机栈-栈帧-对象的内存位置-元空间-常量池-Integer（-128）~127-String

---
- **JVM**：Java Virtual Machine。运行Java程序必不可少的机制，实现了Java平台无关性的特性。我们编写的Java程序并不直接在CPU上执行，而是由JVM执行。JVM屏蔽了与具体平台相关的信息，使Java语言编译程序只需生成在JVM允许的字节码（.class）文件，就可以在多个平台上不加修改的运行。JVM在执行字节码时，把字节码解释成具体机器上的机器指令执行。JVM同时也是Java程序的安全检查引擎。  
	- Java虚拟接本质上是一个程序，当在命令行启动jvm的时候，它就开始执行保存在某个字节码文件中的指令。
	- JVM分为五大模块：类加载器、运行时数据区、执行引擎、本地方法接口、垃圾回收模块。
	- JVM不是真实的物理机，不存在寄存器，所以指令集是使用Java栈（先进后出）来存储中间数据的。
- **运行时数据区域**：
	- ***区域划分***：堆、虚拟机栈、本地方法栈、元空间、程序计数器。
	- ***程序计数器***：线程私有，唯一不会出现OutOfMemoryError的区域，当前线程所执行字节码的行号指示器。
		- 字节码解释器通过改变计数器的值来选取下一条要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成
		- 线程切换后能恢复正确执行的位置
	- ***虚拟机栈***：Java方法执行的内存模型。线程私有、生命周期和线程相同。会出现StackOverFlowError和OutOfMemoryError异常。
		- 每个方法在执行的时候都会创建一个栈帧压入栈中，一个栈帧包括局部变量表、动态链接、操作数栈、方法出口。每个方法从调用到完成对应着一个栈帧入栈到出栈。
			- 局部变量表：变量值存储空间，用于存放方法参数和方法内定义的局部变量。在Java程序编译为class文件时，就确定了该方法所需要分配的局部变量表的最大容量。
			- 动态连接：每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用。持有这个引用是为了支持方法调用过程中的动态连接（将符号引用解析为直接引用）
			- 操作数栈（操作栈）：与字节码指令结合，用来进行运算。在编译时确定其最大深度。可以存放任意Java数据类型（Reference长度为32位），包括long和double。32位所占的容量为1，64位为2。
			- 方法出口：1.执行引擎遇到任意一个方法执行的字节码指令。2.遇到了异常，且未找到匹配的异常处理器。
				- 方法退出时，实质是让栈帧出栈。可能的操作有：1.将返回值压入上层调用栈帧 2.把异常信息抛给能够处理的栈帧 3.PC计数器指向方法调用的下一条指令
			- 在编译程序代码时，栈帧需要多大的局部变量表和多深的操作栈都是确定的，并且写入到方法表的Code属性之中，因此一个栈帧需要分配多大的内存在编译期就确定了。
		- 打印虚拟机栈信息：jstack -l pid
	- ***本地方法栈***：线程私有。为虚拟机执行Native方法服务。会出现StackOverFlowError和OutOfMemoryError异常
	- ***元空间***：线程共享。jdk1.8将方法区更改为元空间。用于存放类元信息、静态成员变量、常量、编译后代码等数据。堆外区域。会出现OurOfMemoryError异常。class文件中，除了类版本、字段、方法、接口等描述信息外，还有常量池，存放的是编译期生成的字面量和符号引用。
		- 运行时常量池：类加载之后存放类常量池的内容，并且将部分符号引用解析为直接引用进行保存。运行时也会有新的常量加入该常量池。
		- String常量池：已经被移入到堆中。需要了解String.intern()方法
	- ***堆***：线程共享。运行时数据区域中占空间最大的区域，几乎所有的对象都存放在堆中。垃圾回收的主要区域。会出现OutOfMemoryError异常。可通过参数-Xms和-Xmx控制堆的大小。默认最小为机器内存的1/64，最大为1/4
		- 新生代：新创建的实例对象会存放到新生代，当对象经历内存回收的次数达到一定值，会迁移到老年代。新生代的对象大部分会很快被回收掉。细分为Eden，From Survivor，To Survivor。
		- 老年代：进入老年代的对象一般比较稳定。
		- 新生代和老年代的比例默认为1:2。可通过-XX:NewRatio来指定。Eden:From:TO=8:1:1，可通过-XX:SurvivorRatio来设定
- **句柄和直接指针**：执行引擎通过引用访问对象的时候，有两种方式。
	- 通过句柄进行访问，在堆中建立一个句柄池，在句柄中存储着对应实例在堆中的位置，引用存储的是句柄的位置。
	- 通过直接指针访问，引用存储的是堆中实例的地址。
	- 句柄访问需要先找到句柄，然后才能找到实例，相对于直接指针访问会慢一些。但是句柄访问的好处在于垃圾回收的时候，只需要改变句柄中实例的位置。在HotSpot虚拟机实现中，采用的是直接指针的方式。
- **符号引用、直接引用、解析**：
	- ***符号引用***：以一组符号来描述所引用的目标，符号可以使任何形式的字面量，只要使用时能无歧义的定位到目标即可。符号引用的字面量形式存在于编译后的class文件中。
	- ***直接引用***：由符号引用在加载时解析为直接引用。可以是直接指向目标的指针、句柄、相对偏移量
	- ***解析***：所有方法调用中的目标方法在class文件中都是一个常量池的符号引用。满足“编译器可知，运行期不变”的方法，将在类加载的解析阶段由符号引用转化为直接引用，并记录在运行期常量池中，这类方法主要包括构造方法、私有方法、静态方法、父类方法，它们不可能被覆盖或者重写为其他版本。
- **静态分派、动态分派**：确定方法分派调用过程。编译器选择静态分派目标（重载方法），运行期选择动态分派目标（重写）
- **对象的内存布局**：对象头、实例数据、对齐填充
	- ***对象头***：包含两部分。1.存储对象运行时数据（Mark Word） 2.类型指针，如果对象是数组的话，还包含数组的长度（4byte）
		- 存储运行时数据：Hash码、GC分代年龄、锁状态标识、线程持有的锁、偏向线程ID、偏向时间戳等。32位jvm下占4byte，64位jvm下占8byte。
		- 类型指针：指向类元数据的指针。32位jvm下占4byte。64位jvm下占8byte，如果开启指针压缩（默认开启），占4byte
	- ***实例数据***：对象真正存储的有效信息
	- ***对齐填充***：jvm规定对象的大小必须是8的倍数，若不足，则填充
	- ***详细参考***：[对象的内存布局](../basic/jvm/对象的内存布局.md)
- **虚拟机类加载机制**：加载、连接（验证、准备、解析）、初始化。虚拟机把描述类的数据从Class文件加载到内存，并对数据进行验证，转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。
	- ***加载***：
		- 通过一个类的全限定名来获取该类的二进制字节流。
		- 将字节流所代表的的静态存储结构转化为元空间的运行时数据结构。
		- 在元空间生成一个代表该类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。
	- ***验证***：确保Class文件的字节流包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全
		- 文件格式验证
		- 元数据验证
		- 字节码验证
		- 符号引用验证
	- ***准备***：正式为类变量分配内存并设置初始值。
	- ***解析***：将常量池内的符号引用替换为直接引用。引用阶段可以在类加载阶段，也可以在某个符号引用将要被使用时解析
	- ***初始化***：执行类构造器<clinit>()方法的过程。
		- <clinit>()方法的生成：由编译器自动收集类中的所有类变量的赋值动作和静态语句块中的语句合并产生。编译器收集的顺序由语句在源文件中出现的顺序所决定，静态语句块中只能访问到定义在静态语句块之前的变量，但是可以对该变量赋值。
		- <clinit>()方法不会显示的调用父类构造器，虚拟机会保证先执行父类的<clinit>()方法
		- <clinit>()方法并不是必须有的，当类中没有静态代码块，并且没有对变量赋值，就不会生成
		- 接口也会生成有<clinit>()方法，但是接口不会先执行父类的<clinit>()方法，除非父接口中定义的变量使用时
		- 虚拟机保证<clinit>()方法是同步的
	- 加载、验证、准备、初始化、卸载这5个步骤的**开始时间**是确定的
- **对类进行初始化（只初始化一次）的情况**：
	- 当遇到new（实例化）、invokestatic（调用静态方法）、getstatic（获取静态属性）、setstatic（设置静态属性）这四条字节码指令时
	- 使用java.lang.reflect包的方法对类进行反射调用时 
	- 对某个类进行初始化时，如果其父类还没有进行过初始化，先初始化其父类（接口的话，不要求其父接口都初始化，只有在真正使用到父接口的时候（如引用接口中定义的变了）才会初始化）
	- Main主类在启动时被初始化
- **对象的实例化**：
	- new关键字
	- Class.newInstance()调用无参构造函数（反射）
	- Constructor.newInstance()可以调用有参构造函数和私有构造函数（反射）
	- Object.clone方法，分为深克隆和浅克隆（因为存在基本数据类型和引用数据类型）
		- 浅克隆对于引用对象，只是复制地址。为了达到深克隆的目的，需要复写clone方法来实现。
		- 也可以通过序列化的方式来实现深克隆
	- 反序列化
- **init方法**：对父类init方法的调用、实例变量初始化的字节码、对应构造器的方法体字节码
- **JMM**：Java Memory Model。Java内存模型。由JVM规范中定义，用来屏蔽掉各种硬件及操作系统的内存访问的差异，以实现Java程序在各种平台下都能达到一致的并发效果。
- **双亲委派模型**：对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名称空间。
	- 类加载器可以划分为：启动类加载器（lib）、拓展类加载器(lib/ext)、系统类加载器（应用程序）。
	- 如果一个类加载器接收到了类加载的请求，它会把这个请求委派给父类加载器完成，每一个层次的加载器都是如此，所以所有的加载请求都会传送到顶层的启动类加载器，只有当父类加载器回馈自己无法完成这个加载请求时，子加载器才会尝试去加载。
	- 为了防止破坏双亲委派模型，当我们自定义类加载器时，一般只需要重写findClass()方法处理具体的逻辑，不需要修改loadCLass()方法