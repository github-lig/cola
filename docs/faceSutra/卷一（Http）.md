网络-ip-通信-网络基础-tcp/ip-各层架构协议-tcp和udp-http-rest  

-- 
- 网络是几乎可以实时发送和接收数据的计算机和其他设备的集合。我们现在用的微信，抖音等软件，数据都是通过网络进行传播。   
- 网络通常用线缆连接，数据位转换为电磁波，通过线缆移动。无线网络会通过无线电波传输数据。
- 网络上的每台机器称为一个节点，比如计算机、打印机、贩卖机、路由器、网关等。每个网络节点都有地址（IPV4、IPV6），用于唯一标识节点的一个字节序列。为了方便记忆，采用域名代替IP地址标识节点地址。
- 域名是由一串用点分隔的字符组成的互联网上某一台计算机或计算机组的名称，用于在数据传输时标识计算机的电子定位。域名可以说是一个IP地址的代称，目的是为了方便记忆后者。比如我们常用的www.baidu.com和www.google.com。
- 域名的核心是域名系统（Domain Name System，简称DNS）。当我们访问www.google.com时，会首先访问DNS服务器（前提是本地的hosts文件中没有该域名的配置），将域名转换为IP地址，这个过程叫做域名解析。
- 现在计算机网络的数据传输都是包交换（分组交换），流经网络的数据分隔成小块，称为包（也称分组）。每个包都单独加以处理，其中包含了由谁发送和将发往何处的信息。这样做的优势在于多个即将交换的包，可以在同一条线缆上传输，使建立网络的成本更低，多个计算机可以互不干扰的使用同一条线缆（如果使用传统的电话线，当你在一个交换区中打本地电话时，实际上你将独占从你的电话到通话人电话之间的一条线缆）。而且分包传输可以进行包的校验，用来检测包在传输中是否遭到破坏。
- 计算机网络传输另一个重要的点是传输协议，比如Http、Ftp、Smtp、Tcp、Udp、Icmp等协议。
- 网络分层：将包从一台主机发送到另一台主机的过程是很复杂的，为了对开发人员和用户隐藏这种复杂性，网络通信的不同方面被分解为多个层。
- OSI七层模型：应用层、表示层、会话层、传输层、网络层、数据链路层、物理层
- TCP/IP五层模型：应用层、传输层、网际层（网络层）、数据链路层、物理层。有的文档把TCP/IP分为四层，数据链路层和物理层合称为主机网络层。
- 数据流向：当我们通过浏览器进行服务器的访问时，从逻辑上来看，数据是从本机的应用层<->服务器应用层，实际上的数据流向为本地应用层->本地传输层->本地网络层->本地数据链路层->物理层->服务器数据链路层->服务器网络层->服务器传输层->服务器应用层（双向）
- 网络层（网际层）：IP（网际协议，世界上使用最广泛的网络层协议）等协议
- 传输层：TCP、UDP等协议
- 应用层：HTTP、SMTP（简单邮件传输协议）、FTP（文件传输协议）、SSH、NFS（网络文件系统，允许网络中的计算机通过TCP/IP网络共享资源）等协议
- IPV4、IPV6：IPV4为32位，IPV6位128位
- TCP、UDP：TCP，传输控制协议。UDP，用户数据包协议。TCP是一种面向连接的，可靠的，基于字节流的传输层协议，支持对丢失或破坏的数据进行重传，并按照发送的顺序进行传送，进行数据传输时，会先进行三次握手，但是传输效率低。而UDP是不可靠的协议，无连接，传输效率高，当对网络通讯质量要求不高时，要求网络通讯速度能尽量的快，可以使用UDP，比如语音、视频等。
- TCP、UDP安全性分析：因为TCP有确认机制，三次握手机制，这些也导致TCP容易被人攻击（可靠不代表安全，正是因为为了可靠性，使流程变长，可侵入点变多）。
- 数据在TCP层称为流，数据分组称为分段。作为比较，数据在IP层称为Datagram，数据分组称为分片，UDP中分组称为message。
- TCP三次握手：TCP协议的数据传输分为三个部分，连接创建、数据传送、连接终止。TCP使用三次握手创建一个连接，首先服务端打开一个Socket（套接字）然后监听来自客户端的链接
	- 客户端通过向服务端发送一个SYN来请求建立连接，SYN附带一个序号A
	- 服务端为每一个合法的SYN回送一个SYN-ACK。ACK的确认码为A+1，SYN-ACK本身有一个序号B
	- 客户端收到服务端的SYN-ACK之后，会向服务端发送一个ACK，确认码为B+1.服务端收到ACK之后，连接正式建立
- TCP三次握手参数调优：当服务端收到客户端的SYN并回送SYN-ACK之后客户端掉线，此时服务端会重发SYN-ACK进行重试，在Linux下，默认的重试的次数为5，重试的间隔时间从1s开始每次翻倍。1s、2s、4s、8s、16s。而第五次重试之后还需要等32s才知道第五次也超时了。也就是需要等待1+2+4+8+16+32=63s后，TCP才会断开这个连接。可以通过参数tcp_synack_retries减少重试次数、tcp_max_syn_backlog增大SYN连接数（接受第一次握手的数量）、tcp_abort_on_overflow决定超出能力时的行为
- 四次挥手：连接终止协议。
	- 客户端发送一个Fin报文，并包含一个希望接收方看到的自己当前的序列号K，用来关闭向服务端的数据发送，同时包含一个ack，表示确认对方最后一次发过来的数据
	- 服务端收到报文之后，返回一个ack，确认码为k+1
	- 服务端关闭客户端的连接，发送一个Fin给客户端
	- 客户端发回ack，确认码为序列号+1
- 三次握手为什么是三次：为了让双方都确认对方可以正常接收和发送报文。第一次客户端发送SYN，服务端收到报文，说明服务端确认客户端可以发送报文；第二次服务端发送SYN + ACK，客户端收到报文，说明客户端确认服务端可以接收和发送报文；第三次客户端发送ACK，说明服务端确认客户端可以正常接收报文。
- 四次挥手为什么是四次：因为TCP连接是全双工的，即连接双方既可以发送数据，也可以接收数据。当被动方接到Fin时，仅仅表示对方不想发送数据了，但是自身还会不会发送数据是由上层应用决定的。需要两次交互来关闭双方的发送通道。
- 端口：每台计算机有65535个端口（传输层协议，TCP和UDP在报文头中，定义了来源端口号和目的端口号）每个端口可以分配给一个特定的服务。端口号0为保留端口，不使用。1-1023为系统使用，比如我们常用的80、22（SSH）、23（Telnet）。
- 防火墙：位于Internet和本地网络之间的一些硬件和软件会检查所有进出的数据，以保证其合法性，这就称为防火墙。防火墙是将本地网络连接到更大的Internet的路由器的一部分，还可以完成其他任务，如网络地址转换。防火墙还可以是一台单独的机器。
- 代理服务器：正向代理、反向代理。流程：客户端->代理服务器->服务器。反向代理，客户端不知道最终要访问的服务器，如ngnix。正向代理，客户端知道将要最终访问到的机器，比如我们访问外网服务器时，可以通过某些运营商提供代理服务器来提升访问的速度。
- 应用层协议Http：超文本传输协议，是一个标准，定义了web客户端如何与服务器对话，以及数据如何从服务器传回客户端。Http指定了客户端与服务端如何建立连接，客户端如何从服务端请求数据，服务端如何响应请求，以及最后如何关闭连接。Http连接使用TCP/IP来传输数据。对于客户端到服务端的每一个请求，步骤可描述如下：
	- 默认情况下，客户端在端口80打开与服务器的一个TCP连接，URL中还可以指定其他端口
	- 客户端向服务器发送消息，请求指定路径上的资源。这个请求包括一个首部，可选地（取决于请求的性质）还可以有一个空行，后面是这个请求的数据。
	- 服务器向客户端发送响应。响应以响应码开头，后面是包含元数据的首部、一个空行以及所请求的文档或错误消息。
	- 服务器关闭连接（取决于Connection属性）
- Http响应码：
	- 1XX：信息。 100 Continue
	- 2XX：SuccessFul 请求成功。200 OK（GET、PATCH、PUT） 201已经生成新的资源（POST） 204资源已经不存在（DELETE）
	- 3XX: Redirection 重定位及重定向。301/302浏览器会直接跳转，303浏览器会让用户决定后续操作
	- 4XX：客户端错误。
		- 400 Bad Request：客户端向服务器发出的请求使用了不正确的语法（服务器不理解客户端的请求，未做任何处理）。
		- 401 Unauthorized：访问这个页面需要身份认证。
		- 403 Forbidden：用户通过了身份认证，但是已经不具备了访问资源所需的权限
		- 404 Not Found：服务器找不到所请求的资源
		- 405 Method Not Allowed：请求方法不支持指定的资源。例如，视图在不支持PUT的WEB服务器上使用PUT放置文件
		- 408 Request Timeout：客户端用了太长时间发送请求，可能是因为网络拥塞的原因。
	- 5XX：服务器错误
		- 500 Internal Server Error：发生了意外情况，服务器不知道如何处理
		- 502 Bad Gateway：只用于作为代理或网关的服务器。它标识该代理在试图完成请求时，从它连接的服务器接收到一个无效的响应。
		- 504 Gateway Timeout：代理服务器在合理的时间内未能接收到上游服务器的响应。
- Http方法：
	- GET（VISIT）：访问服务器资源
	- POST（CREATE）：提交服务器资源，用来创建新的资源
	- PUT（UPDATE）：修改服务器已经存在的资源，使用PUT时需要把资源的所有属性一并提交
	- PATCH（UPDATE）：修改服务器已经存在的资源，使用PATCH时只需要将部分资源属性提交
	- DELETE（DELETE）：从服务器删除资源
	- HEAD、CONNECT、OPTIONS、TRACE
	- 某些客户端只能使用GET和POST方法，那么可以使用POST方法替代PUT、PATCH、DELETE，即通过X-HTTP-Method-Overvide告诉服务器应该使用哪个动词覆盖POST。
- Http请求主体：
	- 一个起始行，包括方法。路径和查询字符串，以及HTTP版本
	- 一个HTTP首部
	- 一个空行（两个连续的回车/换行对）
	- 主体
- Cookie：很多网站使用一些小文本在连接之间存储持久的客户端状态，这些小文本串称为cookie。cookie在请求和响应的HTTP首部，从 服务器传递到客户端，再从客户端传回服务器。
	- 默认情况下，cookie来自哪个服务器就应用于哪个服务器。不过网站也可以指定一个cookie应用于整个子域，而不只是最初的服务器。例如，下面这个请求为整个foo.example.com域设置一个用户cookie： Set-Cookie:user=elharo;Domain=.foo.example.com。浏览器不只是把这个cookie会送到www.foo.example.com，还会发送给lothar.foo.example.com，eliza.foo.example.com域中的任何其他主机。
	- Java提供了CookieManager（cookie管理，启用、接收策略）和CookieStore（本地存放和获取cookie）
- Session：由于Http是无状态的，当服务器需要记录用户的状态时（比如购物车，记录用户权限，登录状态），就需要用某种机制来标识具体的用户，这个机制就是Session。在一次会话中，解决两次http请求的关联，使两次请求可以在服务端找到同一个Session信息，被认为是同一个用户。
	- 服务端如何识别特定的客户：每次Http请求的时候，客户端都会发送相应的Cookie信息到服务端，比如Session_id。如果浏览器禁用了Cookie，会使用URL重写的技术，在URL后面附加一个诸如sid=xxx的参数，服务器据此来识别用户。
- Session和Cookie：Session在服务端（可以存储在内存、数据库、文件），Cookie在客户端浏览器（浏览器内存）
- rest：Rest是一种风格，在Rest风格中，每一个资源都只是对应着一个网址，而一个代表资源的网址应该是一个名词，不应该存在动词，这代表对一个资源的操作。




