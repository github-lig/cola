(window.webpackJsonp=window.webpackJsonp||[]).push([[8],{358:function(t,a,e){"use strict";e.r(a);var r=e(42),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h3",{attrs:{id:"jvm进程正常退出"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#jvm进程正常退出"}},[t._v("#")]),t._v(" JVM进程正常退出")]),t._v(" "),e("p",[t._v("​\t1. 调用System.exit() 或者 Runtime.exit()")]),t._v(" "),e("p",[t._v("​\t2. 所有非daemon线程完全终止")]),t._v(" "),e("h4",{attrs:{id:"如何保证一个进程不结束"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何保证一个进程不结束"}},[t._v("#")]),t._v(" 如何保证一个进程不结束")]),t._v(" "),e("p",[t._v("​\t保证至少一个非daemon线程一直在运行")]),t._v(" "),e("p",[t._v("​\t参考springboot启动tomcat服务")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v('private void startDaemonAwaitThread() {\n    Thread awaitThread = new Thread("container-" + containerCounter.get()) {\n        public void run() {\n            TomcatWebServer.this.tomcat.getServer().await();\n        }\n    };\n    awaitThread.setContextClassLoader(this.getClass().getClassLoader());\n    awaitThread.setDaemon(false);\n    awaitThread.start();\n}\n')])])]),e("p",[t._v("在await方法中执行下述逻辑")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("if (this.getPortWithOffset() == -1) {\n\ttry {\n\t\tthis.awaitThread = Thread.currentThread();\n\t\twhile(!this.stopAwait) {\n\t\t\ttry {\n\t\t\t\tThread.sleep(10000L);\n\t\t\t} catch (InterruptedException var64) {}\n\t\t}\n\t} finally {\n\t\tthis.awaitThread = null;\n\t}\n\n}\n")])])]),e("h3",{attrs:{id:"阻塞队列-非阻塞队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#阻塞队列-非阻塞队列"}},[t._v("#")]),t._v(" 阻塞队列 & 非阻塞队列")]),t._v(" "),e("h4",{attrs:{id:"阻塞队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#阻塞队列"}},[t._v("#")]),t._v(" 阻塞队列")]),t._v(" "),e("p",[t._v("​\t\t阻塞队列多是通过ReentrantLock来实现线程安全性（lock&&unlock）和阻塞（Condition）的特性。阻塞特性体现在调用put和take方法时，如果队列已满，那么put会被阻塞，当队列有空余空间时唤醒并返回，如果队列无元素，那么take会被阻塞，当队列添加了新元素时被唤醒并返回。")]),t._v(" "),e("h5",{attrs:{id:"常用的阻塞队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#常用的阻塞队列"}},[t._v("#")]),t._v(" 常用的阻塞队列")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("LinkedBlockingQueue ：基于链表实现的有界阻塞队列")])]),t._v(" "),e("li",[e("p",[t._v("ArrayBlockingQueue ：基于数组实现的有界阻塞队列")])]),t._v(" "),e("li",[e("p",[t._v("PriorityBlockingQueue：基于优先级的无界阻塞队列")])]),t._v(" "),e("li",[e("p",[t._v("DelayQueue：基于优先级队列实现的延迟队列")])]),t._v(" "),e("li",[e("p",[t._v("SynchronousQueue：不存储元素的阻塞队列")])]),t._v(" "),e("li",[e("p",[t._v("LinkedTransferQueue：链表结构的无界阻塞队列")])]),t._v(" "),e("li",[e("p",[t._v("LinkedBlockingDeque：链表结构的双向阻塞队列")])])]),t._v(" "),e("h5",{attrs:{id:"说明"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#说明"}},[t._v("#")]),t._v(" 说明")]),t._v(" "),e("ul",[e("li",[e("p",[t._v("​\t有界、无界：除了SynchronousQueue队列明确是有界的，其他队列在于有无设置队列大小，如果未设置，默认为Integer.MAX_VALUE，相当于是无界队列。PriorityBlockingQueue即使设置了队列大小，当队列满时，也会进行扩容")])]),t._v(" "),e("li",[e("p",[t._v("LinkedBlockingQueue和ArrayBlockingQueue区别")])]),t._v(" "),e("li",[e("p",[t._v("LinkedBlockingQueue 基于链表实现，动态内存、不指定大小时，默认为Integer.MAX_VALUE。生产和消费使用不同Lock锁")])]),t._v(" "),e("li",[e("p",[t._v("ArrayBlockingQueue基于数组实现，必须指定大小，固定内存，生产和消费使用同一个锁")])]),t._v(" "),e("li",[e("p",[t._v("吞吐量上lbq更高一些，但是在内存分配、回收上，abq性能要差一些")])])]),t._v(" "),e("h4",{attrs:{id:"非阻塞队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#非阻塞队列"}},[t._v("#")]),t._v(" 非阻塞队列")]),t._v(" "),e("ul",[e("li",[t._v("ConcurrentLinkedQueue：线程安全的、非阻塞的、基于链表实现、无界的队列")])]),t._v(" "),e("h3",{attrs:{id:"comparable和comparator"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#comparable和comparator"}},[t._v("#")]),t._v(" Comparable和Comparator")]),t._v(" "),e("ul",[e("li",[t._v("实现Comparable接口，代表该类支持排序")]),t._v(" "),e("li",[t._v("Comparator 是比较器接口，如果需要控制某个类的排序，且该类不支持排序，可以实现一个该类的比较器")])]),t._v(" "),e("h3",{attrs:{id:"mysql"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[t._v("#")]),t._v(" mysql")]),t._v(" "),e("h4",{attrs:{id:"sql执行过程"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sql执行过程"}},[t._v("#")]),t._v(" sql执行过程")]),t._v(" "),e("ul",[e("li",[t._v("查询缓存")]),t._v(" "),e("li",[t._v("解析和预处理\n"),e("ul",[e("li",[t._v("通过关键字将sql解析，生成解析树。Mysql解析器将使用Mqsql语法规则验证和解析查询。")]),t._v(" "),e("li",[t._v("预处理则根据一些MySQL规则进行进一步检查解析树是否合法，例如检查数据表和数据列是否存在。")])])]),t._v(" "),e("li",[t._v("查询优化")]),t._v(" "),e("li",[t._v("执行引擎")])]),t._v(" "),e("h4",{attrs:{id:"脏页"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#脏页"}},[t._v("#")]),t._v(" 脏页")]),t._v(" "),e("p",[t._v("当内存数据页与磁盘数据页数据不一致时，这个内存页称为脏页")]),t._v(" "),e("h3",{attrs:{id:"动态代理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#动态代理"}},[t._v("#")]),t._v(" 动态代理")]),t._v(" "),e("blockquote",[e("p",[t._v("动态代理中所说的“动态”，是针对使用Java代码编写了代理类的“静态“代理而言的，它的优势不在于省去了编写代理类那一点编码工作量，而是实现了可以在原始类和接口还未知的情况下，就确定了代理类的行为，当代理类与原始类脱离了直接联系后，就可以很灵活的重用于不同的应用场景之中。")])]),t._v(" "),e("h3",{attrs:{id:"threadgroup"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#threadgroup"}},[t._v("#")]),t._v(" ThreadGroup")]),t._v(" "),e("p",[t._v("线程组层级：system->main->userGroup（应用程序创建的组）")]),t._v(" "),e("p",[t._v("可以通过线程组管理某些具有特定功能的线程。可以通过线程组对组内线程进行中断等操作")]),t._v(" "),e("h3",{attrs:{id:"二进制安全"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二进制安全"}},[t._v("#")]),t._v(" 二进制安全")]),t._v(" "),e("p",[t._v("只关心二进制的字符串，不关心具体的格式，只会严格的按照二进制的数据存取，不会妄图以某种特殊格式解析数据")]),t._v(" "),e("h3",{attrs:{id:"locksupport"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#locksupport"}},[t._v("#")]),t._v(" LockSupport")])])}),[],!1,null,null,null);a.default=s.exports}}]);